
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">src\server\fileserver.go (81.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package server

import (
        //"bytes"
        "crypto/rand"
        "crypto/sha256"
        "encoding/csv"
        "encoding/hex"
        "encoding/json"
        "flag"
        "fmt"
        "html/template"
        "io"
        "io/ioutil"
        "log"
        "net/http"
        "os"
        "strconv"
        "strings"
        "time"
        "testing"
        "github.com/stretchr/testify/assert"
        "net/http/httptest"
)

var AuthenticatorVar Authenticator = (Authenticator)(&amp;AuthenticatorStruct{})

type AuthenticatorStruct struct{
        AuthenticatorFunc

}

func StartFileserver() <span class="cov0" title="0">{
        log.Println("Server Startet")
        http.HandleFunc("/", index)
        http.HandleFunc("/login", loginHandler)
        http.HandleFunc("/register", newUserHandler)
        http.HandleFunc("/landrive", landrive)
        http.HandleFunc("/uploadFile", uploadFileHandler)
        http.HandleFunc("/getFolderStruct", folderStructHandler)
        http.HandleFunc("/logout", logoutHandler)
        http.HandleFunc("/newFolder", createFolderHandler)
        http.HandleFunc("/delete", deleteHandler)
        http.HandleFunc("/download", downloadHandler)
        http.HandleFunc("/wget", wgetHandler)
        http.HandleFunc("/changePw", changePasswordHandler)
        http.Handle("/static/", http.StripPrefix("/static/", http.FileServer(http.Dir("website"))))
        err := http.ListenAndServeTLS(":"+flag.Lookup("P").Value.String(), flag.Lookup("C").Value.String(), flag.Lookup("K").Value.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("ListenAndServe: ", err)
        }</span>

}

func index(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        cookiecheck, _, _ := checkCookie(w, req)
        log.Println(cookiecheck)
        if cookiecheck </span><span class="cov8" title="1">{
                http.Redirect(w, req, "/landrive", http.StatusMovedPermanently)
        }</span><span class="cov0" title="0"> else {
                t, _ := template.ParseFiles("website/index.html")
                t.Execute(w, nil)
        }</span>
}

func landrive(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        cookiecheck, _, _ := checkCookie(w, req)
        if cookiecheck </span><span class="cov0" title="0">{
                t, err := template.ParseFiles("website/landrive.html")
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        return
                }</span>
                //fmt.Println(string(b))

                <span class="cov0" title="0">t.Execute(w, nil)</span>
        }<span class="cov8" title="1"> else {
                http.Redirect(w, req, "/", http.StatusMovedPermanently)
        }</span>
}

func folderStructHandler(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        cookiecheck, user, _ := checkCookie(w, req)
        if cookiecheck </span><span class="cov8" title="1">{
                log.Println("Loading FolderStruct for user " + user.name)
                folders := getFolderStruct(user.name)
                js, err := json.Marshal(folders)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println(err)
                        return
                }</span>
                <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
                w.Write(js)</span>
        }<span class="cov8" title="1"> else {
                http.Redirect(w, req, "/", http.StatusMovedPermanently)
        }</span>
}

func logoutHandler(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        cookiecheck, user, cookie := checkCookie(w, req)
        if cookiecheck </span><span class="cov8" title="1">{
                log.Println("Logout: " + user.name)
                cookie.Expires = time.Now().Add(-1)
                cookie.Value = ""
                http.SetCookie(w, &amp;cookie)
                http.Redirect(w, req, "/", http.StatusMovedPermanently)
        }</span><span class="cov8" title="1"> else {
                http.Redirect(w, req, "/", http.StatusNotModified)
        }</span>
}

func createFolderHandler(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        cookiecheck, user, _ := checkCookie(w, req)
        if cookiecheck </span><span class="cov8" title="1">{

                path := req.FormValue("path")
                newFolderName := req.FormValue("newFolderName")
                log.Println("Create Folder: " + path + "/" + newFolderName)
                createFolder(user.name + "/" + path + "/" + newFolderName)
                http.Redirect(w, req, "/", http.StatusFound)
        }</span><span class="cov8" title="1"> else {
                http.Redirect(w, req, "/", http.StatusMovedPermanently)
        }</span>
}

func deleteHandler(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        cookiecheck, user, _ := checkCookie(w, req)
        if cookiecheck </span><span class="cov8" title="1">{

                path := req.FormValue("path")
                log.Println("delete: " + path)
                if path != "" </span><span class="cov8" title="1">{
                        os.RemoveAll(flag.Lookup("F").Value.String() + user.name + "/" + path)
                }</span><span class="cov8" title="1"> else {
                        log.Println("Path is empty")
                }</span>

                <span class="cov8" title="1">http.Redirect(w, req, "/", http.StatusFound)</span>
        }<span class="cov8" title="1"> else {
                http.Redirect(w, req, "/", http.StatusMovedPermanently)
        }</span>
}

func downloadHandler(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        cookiecheck, user, _ := checkCookie(w, req)
        if cookiecheck </span><span class="cov8" title="1">{
                path := req.FormValue("path")
                stringarray := strings.Split(path, "/")
                log.Println("Download File: " + path)

                w.Header().Set("Content-Disposition", "attachment; filename=\""+stringarray[len(stringarray)-1]+"\"")

                http.ServeFile(w, req, flag.Lookup("F").Value.String()+user.name+"/"+path)

        }</span><span class="cov8" title="1"> else {
                http.Redirect(w, req, "/", http.StatusMovedPermanently)
        }</span>
}

//wget muss mit den Parameter --no-check-certificate und --auth-no-challenge augerufen werden (am besten auch noch mit --content-disposition
//z.B. wget --user=[username] --password=[password] --no-check-certificate --auth-no-challenge --content-disposition https://[host]:[port]/wget?path=[filepath]
func wgetHandler(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{

        username, password, _ := req.BasicAuth()

        user := loadUser(username)

        log.Println("testing wget")

        if AuthenticatorVar.Authenticate(user, password) </span><span class="cov8" title="1">{
                path := req.URL.Query().Get("path")
                stringarray := strings.Split(path, "/")
                log.Println("Download File from wget: " + path)

                w.Header().Set("Content-Disposition", "attachment; filename=\""+stringarray[len(stringarray)-1]+"\"")

                http.ServeFile(w, req, flag.Lookup("F").Value.String()+user.name+"/"+path)
        }</span><span class="cov8" title="1"> else {
                w.WriteHeader(401)
        }</span>

}

func checkCookie(w http.ResponseWriter, req *http.Request) (bool, user, http.Cookie) <span class="cov8" title="1">{
        cookies := req.Cookies()

        for _, cookie := range cookies </span><span class="cov8" title="1">{
                
                cookieName := cookie.Name
                cookiePw := cookie.Value
                user := loadUser(cookieName)
                if cookiePw == hash([]string{user.name, user.password}) </span><span class="cov8" title="1">{
                        //following 3 lines are responsible for setting the cookie expiration date 15 minutes to the future
                        expiration := time.Now().Add(15 * time.Minute)
                        cookie.Expires = expiration
                        http.SetCookie(w, cookie)
                        return true, *user, *cookie
                }</span>

        }
        <span class="cov8" title="1">return false, user{}, http.Cookie{}</span>
}

func loginHandler(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        log.Println("User tried to log in")
        username := req.FormValue("username")
        password := req.FormValue("password")
        log.Println("User:", username, "Password:", password)
        user := loadUser(username)
        log.Println("Found user: ", user)
        authenticationSuccessful := AuthenticatorVar.Authenticate(user, password)

        if authenticationSuccessful </span><span class="cov8" title="1">{
                loginUser(user, w, req)
        }</span><span class="cov8" title="1"> else {
                http.Redirect(w, req, "?login=false", http.StatusMovedPermanently)
        }</span>

}

func loginUser(user *user, w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        cookieValue := hash([]string{user.name, user.password})
        maxAge, _ := strconv.Atoi(flag.Lookup("T").Value.String())
        cookie := http.Cookie{Name: user.name, Value: cookieValue, MaxAge: maxAge, Expires: time.Now().Add(15*time.Minute)}
        log.Println("Setting cookie")
        http.SetCookie(w, &amp;cookie)
        log.Println("Redirecting to landrive")
        http.Redirect(w, req, "/landrive", http.StatusFound)
}</span>

func newUserHandler(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        log.Println("User tried to register")
        username := req.FormValue("username")
        password := req.FormValue("password")
        password2 := req.FormValue("password2")

        if password == password2 </span><span class="cov8" title="1">{
                user := loadUser(username)
                if user.name != "" </span><span class="cov8" title="1">{
                        http.Redirect(w, req, "?register=userfalse", http.StatusMovedPermanently)
                }</span><span class="cov8" title="1"> else {
                        user := createUser(username, password)
                        loginUser(&amp;user, w, req)
                }</span>
        }<span class="cov8" title="1"> else {
                http.Redirect(w, req, "?register=pwfalse", http.StatusMovedPermanently)
        }</span>

}

func createUser(username string, password string) user <span class="cov8" title="1">{
        salt := generateSalt()
        hashedPw := hash([]string{password, salt})
        log.Println("Creating user with parameters: ", username, hashedPw, salt)
        f, err := os.OpenFile(flag.Lookup("L").Value.String(), os.O_APPEND|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>

        <span class="cov8" title="1">writer := csv.NewWriter(f)
        defer f.Close()

        //writer.Write(username)
        //writer.Write(hashedPw)
        //writer.Write(salt)
        log.Println("Writing to csv")
        writer.Write([]string{username, hashedPw, salt})
        writer.Flush()
        err = writer.Error()
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>

        <span class="cov8" title="1">createFolder(username)
        return user{name: username, password: hashedPw, salt: salt}</span>
}

type Page struct {
        Title string
        Body  []byte
}

func generateSalt() string <span class="cov8" title="1">{
        saltSize := 16
        buf := make([]byte, saltSize)
        _, err := rand.Read(buf)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("random read failed: %v", err)
        }</span>

        <span class="cov8" title="1">return hex.EncodeToString(buf)</span>
}

type user struct {
        name     string
        password string
        salt     string
}

func loadUser(username string) *user <span class="cov8" title="1">{
        f, _ := os.Open(flag.Lookup("L").Value.String())

        r := csv.NewReader(f)
        defer f.Close()
        for </span><span class="cov8" title="1">{
                record, err := r.Read()
                if err == io.EOF </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if record[0] == username </span><span class="cov8" title="1">{
                        return &amp;user{name: record[0], password: record[1], salt: record[2]}
                }</span>
                <span class="cov8" title="1">log.Println(record[0], username)
                log.Println(record[0] == username)</span>
        }
        <span class="cov8" title="1">return &amp;user{name: "", password: "", salt: ""}</span>
}

func (a AuthenticatorFunc) Authenticate(user *user, password string) bool <span class="cov8" title="1">{
        //hasher := sha256.New()
        //hasher.Write([]byte(password))
        //hasher.Write([]byte(user.salt))
        hash := hash([]string{password, user.salt})

        if hash == user.password </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

func hash(strings []string) string <span class="cov8" title="1">{
        hasher := sha256.New()
        for _, value := range strings </span><span class="cov8" title="1">{
                hasher.Write([]byte(value))
        }</span>
        <span class="cov8" title="1">return hex.EncodeToString(hasher.Sum(nil))</span>
}

func createFolder(path string) <span class="cov8" title="1">{
        os.Mkdir(flag.Lookup("F").Value.String()+path, 0777)
}</span>

type Folder struct {
        Name    string
        Files   []File
        Folders []Folder
}

type File struct {
        Name string
        Date time.Time
        Size int64
}

func getFolderStruct(path string) Folder <span class="cov8" title="1">{
        //log.Println(path)
        index := strings.Index(path, "/")
        var name string
        if index &gt; 0 </span><span class="cov0" title="0">{
                name = path[index+1:]
        }</span><span class="cov8" title="1"> else {
                name = path
        }</span>
        <span class="cov8" title="1">files := make([]File, 0)
        folders := make([]Folder, 0)
        //log.Println(name + ": ")
        fileinfos, _ := ioutil.ReadDir(flag.Lookup("F").Value.String() + "/" + path)

        for _, file := range fileinfos </span><span class="cov8" title="1">{
                if file.IsDir() </span><span class="cov0" title="0">{
                        folders = append(folders, getFolderStruct(path+"/"+file.Name()))
                }</span><span class="cov8" title="1"> else {
                        //log.Println(file.Name())
                        fileStruct := File{Name: file.Name(), Date: file.ModTime(), Size: file.Size()}
                        files = append(files, fileStruct)
                }</span>
        }
        <span class="cov8" title="1">folder := Folder{Name: name, Files: files, Folders: folders}
        return folder</span>
}

func uploadFileHandler(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        cookiecheck, user, _ := checkCookie(w, req)
        if cookiecheck </span><span class="cov8" title="1">{
                log.Println("Request to upload a file was made from user " + user.name)

                defer http.Redirect(w, req, "/landrive", http.StatusMovedPermanently)

                //Fileupload orientiert nach https://www.socketloop.com/tutorials/golang-upload-file
                file, header, err := req.FormFile("uploadFile")
                folderPath := req.FormValue("path")
                log.Println("Path where file is going to be placed: " + folderPath)
                if err != nil </span><span class="cov8" title="1">{
                        log.Println(w, err)
                        return
                }</span>

                <span class="cov0" title="0">defer file.Close()

                filepath := flag.Lookup("F").Value.String() + user.name + "/" + folderPath + "/" + header.Filename

                out, err := os.Create(filepath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(w, "Unable to create the file for writing. Check your write access privilege. Path: "+filepath)
                        return
                }</span>

                <span class="cov0" title="0">defer out.Close()

                // write the content from POST to the file
                _, err = io.Copy(out, file)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(w, err)
                }</span>

                <span class="cov0" title="0">log.Println(w, "File uploaded successfully : ")
                log.Println(w, header.Filename)</span>
        }
}

func changePasswordHandler(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{

        log.Println("changePassword")
        cookiecheck, user, cookie := checkCookie(w, req)
        if cookiecheck </span><span class="cov8" title="1">{
                oldPW := req.FormValue("oldPassword")
                newPW := req.FormValue("newPassword")
                newPWToo := req.FormValue("newPassword2")
                if newPW == newPWToo </span><span class="cov8" title="1">{
                        if AuthenticatorVar.Authenticate(&amp;user, oldPW) </span><span class="cov8" title="1">{
                                changePasswordInFile(&amp;user, newPW)
                                log.Println("Set newPW in Cookie: " + user.name)
                                cookie.Expires = time.Now().Add(-1)
                                cookie.Value = ""
                                http.SetCookie(w, &amp;cookie)

                                user := loadUser(user.name)
                                loginUser(user, w, req)
                        }</span>
                }
        }
        <span class="cov8" title="1">http.Redirect(w, req, "/", http.StatusMovedPermanently)</span>

}

func changePasswordInFile(user *user, newPassword string) <span class="cov8" title="1">{
        input, err := ioutil.ReadFile(flag.Lookup("L").Value.String())
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln(err)
        }</span>

        <span class="cov8" title="1">lines := strings.Split(string(input), "\n")

        for i, line := range lines </span><span class="cov8" title="1">{
                if strings.Contains(line, user.name) </span><span class="cov8" title="1">{
                        lines[i] = ""
                }</span>
        }
        <span class="cov8" title="1">output := strings.Join(lines, "\n")
        err = ioutil.WriteFile(flag.Lookup("L").Value.String(), []byte(output), 0644)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln(err)
        }</span>
        <span class="cov8" title="1">createUser(user.name, newPassword)</span>
}

func doRequestWithPassword(t *testing.T, url string) *http.Response <span class="cov8" title="1">{
        client := &amp;http.Client{}
        req, err := http.NewRequest("GET", url, nil)
        assert.NoError(t, err)
        req.SetBasicAuth("Andy", "1234")
        res, err := client.Do(req)
        assert.NoError(t, err)
        return res
}</span>


func createServer (auth AuthenticatorFuncBasic) *httptest.Server<span class="cov8" title="1">{
        return httptest.NewServer(WrapperBasic(auth, func(w http.ResponseWriter, r *http.Request)</span><span class="cov8" title="1">{
                fmt.Fprintln(w, "Hello client")
        }</span>))
}

type Authenticator interface {
        Authenticate(user *user, password string) bool
}

type AuthenticatorFunc func(user *user, password string) bool


type AuthenticatorBasic interface{
        AuthenticateBasic(user, password string) bool
}

type AuthenticatorFuncBasic func(user, password string) bool

func (af AuthenticatorFuncBasic) AuthenticateBasic(user, password string) bool <span class="cov8" title="1">{
        return af(user, password)
}</span>


func WrapperBasic(authenticator AuthenticatorBasic, handler http.HandlerFunc) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                user, pswd, ok := r.BasicAuth()

                if ok &amp;&amp; authenticator.AuthenticateBasic(user, pswd) </span><span class="cov8" title="1">{
                        handler(w, r)
                }</span><span class="cov8" title="1"> else {
                        w.Header().Set("WWW-Authenticate",
                                "Basic realm=\"My Simple Server\"")
                        http.Error(w,
                                http.StatusText(http.StatusUnauthorized),
                                http.StatusUnauthorized)
                }</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
